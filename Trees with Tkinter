import tkinter as tk
from tkinter import ttk, messagebox
import datetime

class ScheduleBuilder:
    def __init__(self, root):
        self.root = root
        root.title("Schedule Builder with Sorting and Filtering")

        self.tasks = []
        self.selected_item = None
        self.current_sort_column = None  # Keeps track of the current sort column
        self.sort_order = True  # True for ascending, False for descending

        self.create_widgets()

    def create_widgets(self):
        # Task input fields
        ttk.Label(self.root, text="Task:").grid(row=0, column=0, sticky=tk.W)
        self.task_entry = ttk.Entry(self.root, width=30)
        self.task_entry.grid(row=0, column=1, sticky=tk.E)

        ttk.Label(self.root, text="Date (YYYY-MM-DD):").grid(row=1, column=0, sticky=tk.W)
        self.date_entry = ttk.Entry(self.root, width=30)
        self.date_entry.grid(row=1, column=1, sticky=tk.E)

        ttk.Label(self.root, text="Time (HH:MM AM/PM):").grid(row=2, column=0, sticky=tk.W)
        self.time_entry = ttk.Entry(self.root, width=30)
        self.time_entry.grid(row=2, column=1, sticky=tk.E)

        ttk.Label(self.root, text="Importance Level:").grid(row=3, column=0, sticky=tk.W)
        self.importance_combobox = ttk.Combobox(self.root, values=["Low", "Medium", "High"], width=27)
        self.importance_combobox.grid(row=3, column=1, sticky=tk.E)
        self.importance_combobox.set("Medium")  # Default to Medium importance

        # Buttons
        add_button = ttk.Button(self.root, text="Add Task", command=self.add_task)
        add_button.grid(row=4, column=1, sticky=tk.E)

        edit_button = ttk.Button(self.root, text="Edit Task", command=self.edit_task)
        edit_button.grid(row=4, column=0, sticky=tk.W)

        delete_button = ttk.Button(self.root, text="Delete Task", command=self.delete_task)
        delete_button.grid(row=4, column=1, sticky=tk.W)

        # Treeview for displaying schedule
        self.tree = ttk.Treeview(self.root, columns=("Date", "Time", "Task", "Importance"), show="headings", height=10)
        self.tree.heading("Date", text="Date", command=lambda: self.sort_column("Date"))
        self.tree.heading("Time", text="Time", command=lambda: self.sort_column("Time"))
        self.tree.heading("Task", text="Task", command=lambda: self.sort_column("Task"))
        self.tree.heading("Importance", text="Importance", command=lambda: self.sort_column("Importance"))

        self.tree.column("Date", width=100, anchor=tk.CENTER)
        self.tree.column("Time", width=150, anchor=tk.CENTER)
        self.tree.column("Task", width=200)
        self.tree.column("Importance", width=100, anchor=tk.CENTER)

        self.tree.grid(row=5, column=0, columnspan=2, pady=10)
        self.tree.bind("<<TreeviewSelect>>", self.on_tree_select)

        # Scrollbar for the treeview
        scrollbar = ttk.Scrollbar(self.root, orient=tk.VERTICAL, command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.grid(row=5, column=2, sticky='ns')

        # Treeview style for color-coding overdue tasks
        self.tree.tag_configure("overdue", foreground="red")

    def add_task(self):
        task = self.task_entry.get()
        date_str = self.date_entry.get()
        time_str = self.time_entry.get()
        importance = self.importance_combobox.get()

        # Validate date and time
        try:
            # Ensure the time format is HH:MM AM/PM
            datetime.datetime.strptime(date_str, '%Y-%m-%d')
            datetime.datetime.strptime(time_str, '%I:%M %p')  # %I for 12-hour format, %p for AM/PM
        except ValueError:
            messagebox.showerror("Invalid Input", "Please enter date as YYYY-MM-DD and time as HH:MM AM/PM.")
            return

        # Add the task with its importance level
        self.tasks.append((date_str, time_str, task, importance))
        self.clear_inputs()
        self.update_schedule_display()

    def edit_task(self):
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a task to edit.")
            return

        item = selected[0]
        values = self.tree.item(item, 'values')

        # Populate entries with selected task values
        self.date_entry.delete(0, tk.END)
        self.date_entry.insert(0, values[0])
        self.time_entry.delete(0, tk.END)
        self.time_entry.insert(0, values[1])
        self.task_entry.delete(0, tk.END)
        self.task_entry.insert(0, values[2])
        self.importance_combobox.set(values[3])

        self.selected_item = item

        # Change Add button to Update
        update_button = ttk.Button(self.root, text="Update Task", command=self.update_task)
        update_button.grid(row=4, column=0, sticky=tk.E)

    def update_task(self):
        if not self.selected_item:
            return

        date_str = self.date_entry.get()
        time_str = self.time_entry.get()
        task = self.task_entry.get()
        importance = self.importance_combobox.get()

        try:
            datetime.datetime.strptime(date_str, '%Y-%m-%d')
            datetime.datetime.strptime(time_str, '%I:%M %p')  # %I for 12-hour format, %p for AM/PM
        except ValueError:
            messagebox.showerror("Invalid Input", "Please enter date as YYYY-MM-DD and time as HH:MM AM/PM.")
            return

        # Update task list
        index = self.tree.index(self.selected_item)
        self.tasks[index] = (date_str, time_str, task, importance)

        self.selected_item = None
        self.clear_inputs()
        self.update_schedule_display()

    def delete_task(self):
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a task to delete.")
            return

        item = selected[0]
        index = self.tree.index(item)

        del self.tasks[index]
        self.tree.delete(item)

    def on_tree_select(self, event):
        self.selected_item = self.tree.selection()[0] if self.tree.selection() else None

    def clear_inputs(self):
        self.task_entry.delete(0, tk.END)
        self.date_entry.delete(0, tk.END)
        self.time_entry.delete(0, tk.END)
        self.importance_combobox.set("Medium")  # Reset to default

    def update_schedule_display(self):
        # Clear current contents
        for item in self.tree.get_children():
            self.tree.delete(item)

        # Sort tasks by importance and then by date/time
        self.tasks.sort(key=lambda x: (x[0], x[1]))  # Sort by Date and Time first

        # Get current datetime for overdue comparison
        now = datetime.datetime.now()

        # Add tasks to the treeview
        for date_str, time_str, task, importance in self.tasks:
            task_datetime = datetime.datetime.strptime(f"{date_str} {time_str}", '%Y-%m-%d %I:%M %p')
            is_overdue = task_datetime < now

            self.tree.insert(
                "", tk.END,
                values=(date_str, time_str, task, importance),
                tags=("overdue",) if is_overdue else ()
            )

    def sort_column(self, col):
        """Sort the Treeview based on the selected column."""
        if col == "Date":
            col_index = 0
        elif col == "Time":
            col_index = 1
        elif col == "Task":
            col_index = 2
        else:
            col_index = 3  # Importance column
        
        # Sort tasks by the selected column
        self.sort_order = not self.sort_order  # Toggle the sort order
        self.tasks.sort(key=lambda x: x[col_index], reverse=not self.sort_order)

        self.update_schedule_display()


if __name__ == "__main__":
    root = tk.Tk()
    schedule_builder = ScheduleBuilder(root)
    root.mainloop()
